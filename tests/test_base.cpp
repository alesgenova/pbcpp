#include <iostream>
#include <Eigen/Core>
#include <cmath>

#include "catch.hpp"
#include "utils/Utils.hpp"
#include "base/DirectCell.hpp"
#include "base/ReciprocalCell.hpp"
#include "base/Coord.hpp"
#include "constants/Constants.hpp"

#include "utils.hpp"

unsigned int Factorial( unsigned int number ) {
    return number <= 1 ? 1 : Factorial(number-1)*number;
}

TEST_CASE( "Basic DirectCell Tests" ) {
    const int n = 100;
    double a, b, c;
    DirectCell cell0;
    //a = 2; b = 3; c = 4;
    //std::cout << a << "  " << b << "  " << c  <<std::endl;
    for (int i = 0; i < n; i++){
        a = randomBetween(0.1, 100.); b = randomBetween(0.1, 100.); c = randomBetween(0.1, 100.);
        cell0 = getOrthoDirectCell(a, b, c);
        REQUIRE( almostEqual(cell0.getVolume(), a*b*c ) );
        REQUIRE( cell0 == cell0 );
    }
}

TEST_CASE( "Basic ReciprocalCell Tests" ) {
    const int n = 100;
    double a, b, c;
    ReciprocalCell cell0;
    for (int i = 0; i < n; i++){
        a = randomBetween(0.1, 100.); b = randomBetween(0.1, 100.); c = randomBetween(0.1, 100.);
        cell0 = getOrthoReciprocalCell(a, b, c);
        REQUIRE( almostEqual(cell0.getVolume(), (TWOPI*TWOPI*TWOPI)/(a*b*c) ) );
        REQUIRE( cell0 == cell0 );
    }
}

TEST_CASE( "DirectCell ReciprocalCell conversion Tests" ) {
    const int n = 100;
    double a, b, c;
    DirectCell cell0, cell1;
    ReciprocalCell reciprocal0, reciprocal1;

    for (int i = 0; i < n; i++){
        a = randomBetween(0.1, 100.); b = randomBetween(0.1, 100.); c = randomBetween(0.1, 100.);
        // cells generated 
        cell0 = getOrthoDirectCell(a, b, c);
        reciprocal0 = getOrthoReciprocalCell(a, b, c);
        // cells generated by conversion
        reciprocal1 = cell0.getReciprocal();
        cell1 = reciprocal1.getDirect();
        REQUIRE( almostEqual(cell0.getVolume(), a*b*c ) );
        REQUIRE( almostEqual(cell1.getVolume(), a*b*c ) );
        REQUIRE( cell0 == cell1 );
        REQUIRE( !(cell0 != cell1) );
        REQUIRE( almostEqual(reciprocal1.getVolume(), (TWOPI*TWOPI*TWOPI)/(a*b*c) ) );
        REQUIRE( reciprocal0 == reciprocal1 );
        REQUIRE( !(reciprocal0 != reciprocal1) );
    }
}

TEST_CASE( "Coord Basic Tests" ) {
    const int n = 100;
    double a, b, c;
    DirectCell cell0;
    Eigen::Vector3d pos0;
    Coord rcoord0, rcoord1, scoord0, scoord1;
    
    for (int i = 0; i < n; i++){
        a = randomBetween(0.1, 100.); b = randomBetween(0.1, 100.); c = randomBetween(0.1, 100.);
        cell0 = getOrthoDirectCell(a, b, c);
        pos0 << randomBetween(-100, 100.),
                randomBetween(-100, 100.),
                randomBetween(-100, 100.);
        // rcoord is a cartesian coordinate
        rcoord0 = Coord(pos0, cell0, 'r');
        // scoord0 is rcoord0 in crystal basis
        scoord0 = rcoord0.toCrys();
        // rcoord1 is scoord0 in cartesian basis (i.e. back to rcoord0)
        rcoord1 = scoord0.toBasis('r'); // equivalent to scoord0.toCart()
        // adding integer values to a crystal coordinate is equivalent to a translation by a lattice vector
        // so scoord1 is still technically equivalent to scoord0
        pos0 << floor(randomBetween(-100, 100.)),
                floor(randomBetween(-100, 100.)),
                floor(randomBetween(-100, 100.));
        scoord1 = Coord(scoord0.getPos()+pos0, cell0, 's');

        REQUIRE( almostEqual(rcoord0.dd_MIC(scoord0), 0.) );
        REQUIRE( rcoord0 == scoord0 );
        REQUIRE( !(rcoord0 != scoord0) );
        REQUIRE( almostEqual(rcoord0.dd_MIC(scoord1), 0.) );
        REQUIRE( rcoord0 == scoord1 );
        REQUIRE( almostEqual(rcoord0.dd_MIC(rcoord1), 0.) );
        REQUIRE( rcoord0 == rcoord1 );
        REQUIRE( almostEqual(scoord0.dd_MIC(scoord1), 0.) );
        REQUIRE( scoord0 == scoord1 );
        REQUIRE( scoord0.getBasis() == 's' );
        REQUIRE( rcoord0.getBasis() == 'r' );
    }
}